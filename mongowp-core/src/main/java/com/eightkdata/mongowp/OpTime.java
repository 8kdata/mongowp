/*
 * Copyright 2014 8Kdata Technology
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.eightkdata.mongowp;

import com.eightkdata.mongowp.bson.BsonDateTime;
import com.eightkdata.mongowp.bson.BsonDocument;
import com.eightkdata.mongowp.bson.BsonInt64;
import com.eightkdata.mongowp.bson.BsonTimestamp;
import com.eightkdata.mongowp.bson.BsonValue;
import com.eightkdata.mongowp.bson.utils.DefaultBsonValues;
import com.eightkdata.mongowp.bson.utils.TimestampToDateTime;
import com.eightkdata.mongowp.exceptions.NoSuchKeyException;
import com.eightkdata.mongowp.exceptions.TypesMismatchException;
import com.eightkdata.mongowp.fields.DateTimeField;
import com.eightkdata.mongowp.fields.LongField;
import com.eightkdata.mongowp.fields.TimestampField;
import com.eightkdata.mongowp.utils.BsonDocumentBuilder;
import com.eightkdata.mongowp.utils.BsonReaderTool;
import com.google.common.primitives.UnsignedLongs;

import java.io.Serializable;
import java.util.Objects;

import javax.annotation.Nonnull;

/**
 * OpTime encompasses an Instant and a 64-bit Term number. OpTime can be used to label every op in
 * an oplog with a unique identifier.
 */
public class OpTime implements Comparable<OpTime>, Serializable {

  private static final TimestampField TIMESTAMP_FIELD = new TimestampField("ts");
  private static final LongField TERM_FIELD = new LongField("t");
  private static final long serialVersionUID = 2849102384020201828L;
  /**
   * The term of an OpTime generated by old protocol version.
   */
  private static final long UNINITIALIZED_TERM = -1;
  private static final BsonInt64 UNINITIALIZED_TERM_BSON = DefaultBsonValues.newLong(-1);
  /**
   * The initial term after the first time upgrading from protocol version 0.
   *
   * <p>This is also the initial term for nodes that were recently started up but have not yet
   * joined the cluster, all in protocol version 1.
   */
  private static final long INITIAL_TERM = 0;
  /**
   * Default OpTime, also the smallest one.
   */
  public static final OpTime EPOCH = new OpTime(
      DefaultBsonValues.newTimestamp(0, 0),
      UNINITIALIZED_TERM);

  private final BsonTimestamp timestamp;
  private final long term;

  public OpTime(BsonTimestamp timestamp, long term) {
    this.timestamp = timestamp;
    this.term = term;
  }

  /**
   * Constructor used to create optimes from older replication versions, where {@link #getTerm()} is
   * initialized to a default value.
   */
  public OpTime(BsonTimestamp timestamp) {
    this(timestamp, UNINITIALIZED_TERM);
  }

  public static OpTime ofSeconds(int seconds) {
    return new OpTime(DefaultBsonValues.newTimestamp(seconds, 0));
  }

  @Nonnull
  public static OpTime fromBson(BsonDocument doc)
      throws TypesMismatchException, NoSuchKeyException {
    BsonTimestamp ts = BsonReaderTool.getTimestamp(doc, TIMESTAMP_FIELD);
    //TODO(gortiz): check precision lost
    long term = BsonReaderTool.getNumeric(doc, TERM_FIELD)
        .getValue()
        .longValue();
    return new OpTime(ts, term);

  }

  public static OpTime fromOldBson(BsonValue<?> val) {
    BsonTimestamp ts = TimestampToDateTime.toTimestamp(
        val.asDateTime(), DefaultBsonValues::newTimestamp);
    return new OpTime(ts);
  }

  /**
   * Return the serialization of this optime on a bson, using the old version.
   */
  public BsonDateTime toOldBson() {
    return DefaultBsonValues.newDateTime(getTimestamp());
  }

  public void appendAsOldBson(BsonDocumentBuilder builder, String fieldId) {
    builder.appendUnsafe(fieldId, toOldBson());
  }

  public void appendAsOldBson(BsonDocumentBuilder builder, DateTimeField field) {
    appendAsOldBson(builder, field.getFieldName());
  }

  @Nonnull
  public static OpTime fromOplogEntry(BsonDocument doc) throws TypesMismatchException,
      NoSuchKeyException {
    BsonTimestamp ts = BsonReaderTool.getTimestamp(doc, TIMESTAMP_FIELD);
    //TODO(gortiz): check precision lost
    long term = BsonReaderTool.getNumeric(doc, TERM_FIELD, UNINITIALIZED_TERM_BSON)
        .getValue()
        .longValue();
    return new OpTime(ts, term);
  }

  public int getSecs() {
    return timestamp.getSecondsSinceEpoch();
  }

  public long getTerm() {
    return term;
  }

  public BsonTimestamp getTimestamp() {
    return timestamp;
  }

  public BsonDocument toBson() {
    return new BsonDocumentBuilder(2)
        .append(TIMESTAMP_FIELD, timestamp)
        .append(TERM_FIELD, term)
        .build();
  }

  @Override
  public int hashCode() {
    int hash = 5;
    hash = 13 * hash + Objects.hashCode(this.timestamp);
    hash = 13 * hash + (int) (this.term ^ (this.term >>> 32));
    return hash;
  }

  @Override
  public boolean equals(Object obj) {
    if (this == obj) {
      return true;
    }
    if (obj == null) {
      return false;
    }
    if (getClass() != obj.getClass()) {
      return false;
    }
    final OpTime other = (OpTime) obj;
    if (this.term != other.term) {
      return false;
    }
    if (!Objects.equals(this.timestamp, other.timestamp)) {
      return false;
    }
    return true;
  }

  @Override
  public int compareTo(OpTime obj) {
    int diff = timestamp.compareTo(obj.getTimestamp());
    if (diff != 0) {
      return diff;
    }
    return UnsignedLongs.compare(term, obj.getTerm());
  }

  public final boolean isAfter(@Nonnull OpTime other) {
    return compareTo(other) > 0;
  }

  public final boolean isEqualOrAfter(@Nonnull OpTime other) {
    return compareTo(other) >= 0;
  }

  public final boolean isBefore(@Nonnull OpTime other) {
    return compareTo(other) < 0;
  }

  public final boolean isEqualOrBefore(@Nonnull OpTime other) {
    return compareTo(other) <= 0;
  }

  @Override
  public String toString() {
    return "{t: " + timestamp + ", i: " + UnsignedLongs.toString(term) + "}";
  }
}
